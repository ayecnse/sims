<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AyeCNSe V1.4 - Quadruped K9</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #050507; color: #fff; font-family: 'Inter', sans-serif; }
        .jetbrains { font-family: 'JetBrains Mono', monospace; }
        .glass { background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.1); }
        .accent-orange { color: #f97316; text-shadow: 0 0 10px rgba(249, 115, 22, 0.5); }
    </style>
</head>
<body>

    <div class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-6">
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass p-5 rounded-xl border-l-4 border-orange-500">
                <h1 class="text-orange-400 font-bold text-xl tracking-tight">AyeCNSe <span class="text-white">K9 UNIT V1.4</span></h1>
                <p class="text-[10px] text-slate-400 uppercase mt-1">Embodiment: 12-DOF Quadruped</p>
            </div>

            <div class="glass p-4 rounded-xl w-72">
                <h2 class="text-xs font-bold mb-3 text-slate-300 border-b border-slate-800 pb-2 uppercase">Gait Telemetry</h2>
                <div class="space-y-2 text-xs jetbrains">
                    <div class="flex justify-between"><span>STATUS:</span> <span id="tel-status" class="text-orange-400">STANDING</span></div>
                    <div class="flex justify-between"><span>POSTURE HGT:</span> <span id="tel-height">0.00m</span></div>
                    <div class="flex justify-between"><span>VELOCITY:</span> <span id="tel-vel">0 m/s</span></div>
                </div>
            </div>
        </div>

        <div class="glass p-4 rounded-xl pointer-events-auto flex gap-6 h-64">
            <div class="flex-grow flex flex-col">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-xs font-bold text-slate-500 uppercase tracking-widest">K9 ILM Sequence</span>
                </div>
                <textarea id="ilmInput" class="flex-grow bg-slate-950 p-4 text-xs jetbrains text-orange-100 outline-none rounded-lg border border-slate-800 resize-none leading-relaxed">
// K9 Patrol Sequence
STAND()
WALK(5)
TURN(90)
WALK(3)
CROUCH()
WAIT(1)
STAND()
TURN(-90)</textarea>
            </div>
            <div class="w-48 flex flex-col gap-3">
                <button onclick="sim.runSequence()" class="h-full bg-orange-600 hover:bg-orange-500 text-white font-bold rounded-lg transition-all uppercase tracking-tighter">Execute Mission</button>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        class AyeK9Sim {
            constructor() {
                this.legs = [];
                this.isWalking = false;
                this.walkTime = 0;
                this.initEngine();
                this.createK9();
                this.createEnvironment();
                this.animate();
                this.defaultHeight = 1.3;
            }

            initEngine() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x020617);
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(5, 3, 5);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.target.set(0,1,0);

                // Lighting
                const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 5);
                dirLight.castShadow = true;
                this.scene.add(dirLight);
            }

            createK9() {
                const bodyMat = new THREE.MeshPhongMaterial({ color: 0x334155 });
                const legMat = new THREE.MeshPhongMaterial({ color: 0x475569 });
                const jointMat = new THREE.MeshPhongMaterial({ color: 0xf97316 });

                this.k9Group = new THREE.Group();
                this.k9Group.position.y = this.defaultHeight;

                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.6, 0.8), bodyMat);
                this.k9Group.add(body);
                
                // Head Sensor
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.5), bodyMat);
                head.position.set(1.2, 0.2, 0);
                this.k9Group.add(head);

                // Legs (Procedural Generation)
                const legPositions = [
                    {x: 0.8, z: 0.5, name: 'FL'}, // Front Left
                    {x: 0.8, z: -0.5, name: 'FR'}, // Front Right
                    {x: -0.8, z: 0.5, name: 'BL'}, // Back Left
                    {x: -0.8, z: -0.5, name: 'BR'} // Back Right
                ];

                legPositions.forEach(pos => {
                    const legRoot = new THREE.Group();
                    legRoot.position.set(pos.x, 0, pos.z);
                    this.k9Group.add(legRoot);

                    // Hip Joint (Shoulder)
                    const hip = new THREE.Mesh(new THREE.SphereGeometry(0.15), jointMat);
                    legRoot.add(hip);

                    // Upper Leg
                    const upperLeg = new THREE.Group();
                    hip.add(upperLeg);
                    const ulMesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), legMat);
                    ulMesh.position.y = -0.4;
                    upperLeg.add(ulMesh);

                    // Knee Joint
                    const knee = new THREE.Group();
                    knee.position.y = -0.8;
                    upperLeg.add(knee);
                    const kneeJointMesh = new THREE.Mesh(new THREE.SphereGeometry(0.12), jointMat);
                    knee.add(kneeJointMesh);

                    // Lower Leg
                    const lowerLeg = new THREE.Group();
                    knee.add(lowerLeg);
                    const llMesh = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.8, 0.15), legMat);
                    llMesh.position.y = -0.4;
                    lowerLeg.add(llMesh);

                    // Store references for animation
                    this.legs.push({ root: legRoot, upper: upperLeg, lower: lowerLeg, name: pos.name, offset: (pos.name.includes('F') ? 0 : Math.PI) });
                });

                this.scene.add(this.k9Group);
            }

            createEnvironment() {
                const grid = new THREE.GridHelper(20, 20, 0x1e293b, 0x0f172a);
                this.scene.add(grid);
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshPhongMaterial({color:0x0f172a}));
                plane.rotation.x = -Math.PI/2;
                plane.receiveShadow = true;
                this.scene.add(plane);
            }

            async runSequence() {
                const lines = document.getElementById('ilmInput').value.split('\n');
                for(let line of lines) {
                    if(line.startsWith('//') || !line.trim()) continue;
                    const match = line.match(/(.+)\((.*)\)/);
                    if(match) {
                        const cmd = match[1].trim();
                        const val = match[2].trim();
                        await this.execute(cmd, val);
                    }
                }
            }

            async execute(cmd, val) {
                document.getElementById('tel-status').innerText = cmd;
                switch(cmd) {
                    case 'WALK': await this.actionWalk(parseFloat(val)); break;
                    case 'TURN': await this.actionTurn(parseFloat(val)); break;
                    case 'CROUCH': await this.actionPose(0.8); break;
                    case 'STAND': await this.actionPose(this.defaultHeight); break;
                    case 'WAIT': await new Promise(r => setTimeout(r, parseFloat(val)*1000)); break;
                }
                document.getElementById('tel-status').innerText = "IDLE";
                document.getElementById('tel-vel').innerText = "0 m/s";
            }

            actionWalk(distance) {
                return new Promise(res => {
                    this.isWalking = true;
                    let traveled = 0;
                    const speed = 0.05;
                    document.getElementById('tel-vel').innerText = (speed*60).toFixed(1) + " m/s (Sim)";
                    const step = () => {
                        this.k9Group.translateX(speed);
                        traveled += speed;
                        if(traveled < distance) requestAnimationFrame(step);
                        else {
                            this.isWalking = false;
                            this.resetLegs();
                            res();
                        }
                    };
                    step();
                });
            }

            actionTurn(deg) {
                return new Promise(res => {
                    const target = this.k9Group.rotation.y + (deg * Math.PI/180);
                    const step = () => {
                        this.k9Group.rotation.y += (deg > 0 ? 0.02 : -0.02);
                        if(Math.abs(this.k9Group.rotation.y - target) > 0.03) requestAnimationFrame(step);
                        else res();
                    };
                    step();
                });
            }

            actionPose(targetHeight) {
                return new Promise(res => {
                    const step = () => {
                        this.k9Group.position.y += (targetHeight - this.k9Group.position.y) * 0.1;
                        if(Math.abs(this.k9Group.position.y - targetHeight) > 0.01) requestAnimationFrame(step);
                        else {
                             // Adjust leg angles based on height (Simple IK approximation)
                            const crouchFactor = (this.defaultHeight - this.k9Group.position.y);
                            this.legs.forEach(leg => {
                                leg.upper.rotation.z = crouchFactor;
                                leg.lower.rotation.z = -crouchFactor * 1.5;
                            });
                            res();
                        }
                    };
                    step();
                });
            }

            resetLegs() {
                this.legs.forEach(leg => {
                    leg.upper.rotation.z = 0;
                    leg.lower.rotation.z = 0;
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Procedural Gait Animation Engine
                if(this.isWalking) {
                    this.walkTime += 0.1;
                    this.legs.forEach((leg, i) => {
                        // Trot Gait: Diagonal pairs move together
                        const gaitOffset = (leg.name === 'FL' || leg.name === 'BR') ? 0 : Math.PI;
                        const stride = Math.sin(this.walkTime + gaitOffset);
                        
                        // Simple leg swing
                        leg.upper.rotation.z = stride * 0.3;
                        // Knee bend on forward swing
                        leg.lower.rotation.z = (stride > 0) ? -stride * 0.5 : 0;
                    });
                    // Bob body slightly
                    this.k9Group.position.y = this.defaultHeight + Math.sin(this.walkTime*2)*0.05;
                }

                document.getElementById('tel-height').innerText = this.k9Group.position.y.toFixed(2) + 'm';
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        const sim = new AyeK9Sim();
        window.addEventListener('resize', () => {
            sim.camera.aspect = window.innerWidth / window.innerHeight;
            sim.camera.updateProjectionMatrix();
            sim.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
