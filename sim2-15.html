<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AyeCNSe V3.0 - Full Parametric Humanoid</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #050507; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .glass { background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.1); }
        .jetbrains { font-family: 'JetBrains Mono', monospace; font-size: 11px; }
        .pointer-auto { pointer-events: auto; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="relative z-10 h-screen pointer-events-none flex flex-col justify-between p-6">
        <div class="glass p-5 rounded-xl border-l-4 border-blue-500 w-fit pointer-auto">
            <h1 class="text-blue-500 font-bold text-xl uppercase tracking-tighter">AyeCNSe <span class="text-white">V3.0_PARAMETRIC</span></h1>
            <p class="text-[10px] text-slate-400 uppercase tracking-widest mt-1">DOF: 18 | Physics: Real-Time Kinematics</p>
        </div>

        <div class="glass p-4 rounded-xl pointer-auto flex gap-4 h-80 w-full max-w-5xl self-center">
            <div class="flex-grow flex flex-col">
                <span class="text-[10px] font-bold text-slate-500 uppercase mb-2">Universal Command Input</span>
                <textarea id="ilmInput" class="flex-grow bg-black p-4 jetbrains text-blue-300 outline-none rounded-lg border border-slate-800 resize-none leading-relaxed">
// 6-DOF BHANGRA PARAMETRIC SEQUENCE
ARM_L_SHOULDER_PITCH(45)
ARM_R_SHOULDER_PITCH(45)
ARM_L_SHOULDER_ROLL(90)
ARM_R_SHOULDER_ROLL(-90)
ARM_L_ELBOW(-60)
ARM_R_ELBOW(-60)
PELVIS_Y(1.0) // Deep Sit
WAIT(0.5)
JUMP(3.0)     // Physics-based impulse
WAIT(1)
RESET()</textarea>
            </div>
            <div class="w-56 flex flex-col gap-2">
                <button onclick="sim.run()" class="flex-grow bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl transition-all uppercase text-sm shadow-lg shadow-blue-900/40">Execute Intent</button>
                <div class="bg-slate-900 p-3 rounded-lg jetbrains text-[9px] text-blue-400 border border-blue-500/20">
                    <div class="flex justify-between"><span>COM_Y:</span><span id="tel-y">0.0</span></div>
                    <div class="flex justify-between"><span>VEL_Y:</span><span id="tel-vy">0.0</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ParametricSim {
            constructor() {
                this.gravity = -0.015;
                this.velY = 0;
                this.isJumping = false;
                this.joints = {};
                this.init();
            }

            init() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(6, 4, 8);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                
                const sun = new THREE.DirectionalLight(0xffffff, 1.2);
                sun.position.set(5, 10, 7);
                this.scene.add(sun, new THREE.AmbientLight(0xffffff, 0.4));
                this.scene.add(new THREE.GridHelper(40, 40, 0x1e293b, 0x0f172a));

                this.buildHumanoid();
                this.animate();
            }

            buildHumanoid() {
                this.bot = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: 0x334155 });
                
                // Pelvis (Root)
                this.pelvis = new THREE.Group();
                this.pelvis.position.y = 2.4;
                this.bot.add(this.pelvis);
                this.pelvis.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 0.6), mat));

                // Torso
                this.torso = new THREE.Group();
                this.torso.position.y = 0.2;
                this.pelvis.add(this.torso);
                this.torso.add(new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.3, 0.6), mat));

                // Arms (6-DOF each)
                this.arms = {
                    L: this.createArm(-0.75, this.torso, mat, 'L'),
                    R: this.createArm(0.75, this.torso, mat, 'R')
                };

                // Legs
                this.legs = {
                    L: this.createLeg(-0.35, this.pelvis, mat),
                    R: this.createLeg(0.35, this.pelvis, mat)
                };

                this.scene.add(this.bot);
            }

            createArm(xSide, parent, mat, side) {
                const shP = new THREE.Group(); shP.position.set(xSide, 0.4, 0); parent.add(shP);
                const shR = new THREE.Group(); shP.add(shR);
                const upper = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), mat); upper.position.y = -0.4; shR.add(upper);
                const elbow = new THREE.Group(); elbow.position.y = -0.8; upper.add(elbow);
                const lower = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.8, 0.18), mat); lower.position.y = -0.4; elbow.add(lower);
                
                this.joints[`ARM_${side}_SHOULDER_PITCH`] = shP.rotation;
                this.joints[`ARM_${side}_SHOULDER_ROLL`] = shR.rotation;
                this.joints[`ARM_${side}_ELBOW`] = elbow.rotation;
                return { shP, shR, elbow };
            }

            createLeg(x, parent, mat) {
                const hip = new THREE.Group(); hip.position.set(x, -0.2, 0); parent.add(hip);
                const upper = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), mat); upper.position.y = -0.6; hip.add(upper);
                const knee = new THREE.Group(); knee.position.y = -0.6; upper.add(knee);
                const lower = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1.2, 0.25), mat); lower.position.y = -0.6; knee.add(lower);
                return { hip, knee };
            }

            async run() {
                const lines = document.getElementById('ilmInput').value.split('\n');
                for (let line of lines) {
                    if (!line.trim() || line.startsWith('//')) continue;
                    const match = line.match(/(.+)\((.*)\)/);
                    if (match) {
                        const cmd = match[1].trim();
                        const val = parseFloat(match[2]);
                        const rad = (val * Math.PI) / 180;

                        if (this.joints[cmd]) {
                            const axis = cmd.includes('ROLL') ? 'z' : 'x';
                            this.joints[cmd][axis] = rad;
                        } else if (cmd === 'PELVIS_Y') {
                            this.pelvis.position.y = 2.4 * val;
                        } else if (cmd === 'JUMP') {
                            this.velY = val * 0.15;
                            this.isJumping = true;
                        } else if (cmd === 'RESET') {
                            Object.values(this.joints).forEach(j => { j.x = 0; j.y = 0; j.z = 0; });
                            this.pelvis.position.y = 2.4;
                        } else if (cmd === 'WAIT') {
                            await new Promise(r => setTimeout(r, val * 1000));
                        }
                    }
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.isJumping || this.bot.position.y > 0) {
                    this.bot.position.y += this.velY;
                    this.velY += this.gravity;
                    if (this.bot.position.y <= 0) {
                        this.bot.position.y = 0;
                        this.velY = 0;
                        this.isJumping = false;
                    }
                }

                document.getElementById('tel-y').innerText = this.bot.position.y.toFixed(2);
                document.getElementById('tel-vy').innerText = this.velY.toFixed(2);
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }
        const sim = new ParametricSim();
    </script>
</body>
</html>
