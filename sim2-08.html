<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AyeCNSe V1.7 - 6-DOF Humanoid Fixed</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #050507; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .ui-layer { position: relative; z-index: 10; pointer-events: none; height: 100vh; display: flex; flex-direction: column; justify-content: space-between; padding: 24px; }
        .pointer-auto { pointer-events: auto; }
        .glass { background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.1); }
        .jetbrains { font-family: 'JetBrains Mono', monospace; font-size: 11px; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="flex justify-between items-start pointer-auto">
            <div class="glass p-5 rounded-xl border-l-4 border-blue-500">
                <h1 class="text-blue-400 font-bold text-xl tracking-tighter uppercase">AyeCNSe <span class="text-white">Humanoid_Fixed</span></h1>
                <p class="text-[10px] text-slate-400 uppercase mt-1">Joint Hierarchy: Connected | DOF: 18 Total</p>
            </div>

            <div class="glass p-4 rounded-xl w-72">
                <h2 class="text-xs font-bold mb-2 text-slate-300 uppercase">Kinematic Telemetry</h2>
                <div class="grid grid-cols-2 gap-2 jetbrains text-blue-300">
                    <div>L_SHOULDER: <span id="tel-ls">0°</span></div>
                    <div>R_SHOULDER: <span id="tel-rs">0°</span></div>
                    <div>ELBOWS: <span id="tel-eb">0°</span></div>
                    <div>STABILITY: <span class="text-green-400">ACTIVE</span></div>
                </div>
            </div>
        </div>

        <div class="glass p-4 rounded-xl pointer-auto flex gap-6 h-80">
            <div class="flex-grow flex flex-col">
                <span class="text-[10px] font-bold text-slate-500 uppercase mb-2">6-DOF Bilateral Command Engine</span>
                <textarea id="ilmInput" class="flex-grow bg-slate-950 p-4 jetbrains text-blue-100 outline-none rounded-lg border border-slate-800 resize-none leading-relaxed">
// Full 6-DOF Arm Test
ARM_L_SH_PITCH(45)
ARM_R_SH_PITCH(45)
ARM_L_SH_ROLL(30)
ARM_R_SH_ROLL(-30)
ARM_L_ELBOW(90)
ARM_R_ELBOW(90)
ARM_L_WR_PITCH(45)
ARM_R_WR_PITCH(45)
ARM_L_WR_ROLL(90)
GRIP_L(CLOSE)

WAIT(2)
RESET()</textarea>
            </div>
            <div class="w-48 flex flex-col gap-2">
                <button onclick="sim.run()" class="flex-grow bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-lg transition-all text-sm uppercase shadow-lg shadow-blue-900/20">Execute Batch</button>
                <button onclick="sim.resetView()" class="p-2 bg-slate-800 text-[10px] text-white rounded font-bold uppercase">Center Camera</button>
            </div>
        </div>
    </div>

    <script>
        class HumanoidSim {
            constructor() {
                this.isWalking = false;
                this.walkTime = 0;
                this.init();
            }

            init() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x020617);
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(6, 4, 8);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.target.set(0, 2, 0);

                const ambient = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambient);
                const sun = new THREE.DirectionalLight(0xffffff, 1.2);
                sun.position.set(5, 10, 5);
                sun.castShadow = true;
                this.scene.add(sun);

                this.scene.add(new THREE.GridHelper(30, 30, 0x1e293b, 0x0f172a));
                this.buildHumanoid();
                this.animate();
            }

            buildHumanoid() {
                this.bot = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: 0x334155 });
                const jointMat = new THREE.MeshStandardMaterial({ color: 0x3b82f6 });

                // Pelvis (Base)
                this.pelvis = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.4, 0.6), mat);
                this.pelvis.position.y = 2.4;
                this.bot.add(this.pelvis);

                // Torso (Parented to Pelvis)
                this.torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.4, 0.7), mat);
                this.torso.position.y = 0.9;
                this.pelvis.add(this.torso);

                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), mat);
                head.position.y = 1.0;
                this.torso.add(head);

                // Fixed Legs Hierarchy (Pelvis -> Hip -> Upper -> Knee -> Lower)
                this.legs = {
                    L: this.createLeg(-0.35, this.pelvis, mat, jointMat),
                    R: this.createLeg(0.35, this.pelvis, mat, jointMat)
                };

                // Upgraded 6-DOF Arms (Shoulder P/R, Elbow P, Wrist P/R/Y)
                this.arms = {
                    L: this.createArm(-0.8, this.torso, mat, jointMat),
                    R: this.createArm(0.8, this.torso, mat, jointMat)
                };
                
                this.scene.add(this.bot);
            }

            createLeg(xPos, parent, mat, jointMat) {
                const hip = new THREE.Group();
                hip.position.set(xPos, -0.1, 0);
                parent.add(hip);

                const upper = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.2, 0.35), mat);
                upper.position.y = -0.6;
                hip.add(upper);

                const knee = new THREE.Group();
                knee.position.y = -0.6; // Positioned relative to upper leg center
                upper.add(knee);

                const lower = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), mat);
                lower.position.y = -0.6;
                knee.add(lower);

                const foot = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.15, 0.7), jointMat);
                foot.position.y = -0.6;
                lower.add(foot);

                return { hip, knee };
            }

            createArm(xSide, parent, mat, jointMat) {
                // J1 & J2: Shoulder (Pitch & Roll)
                const shPitch = new THREE.Group();
                shPitch.position.set(xSide, 0.5, 0);
                parent.add(shPitch);

                const shRoll = new THREE.Group();
                shPitch.add(shRoll);

                const upper = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), mat);
                upper.position.y = -0.4;
                shRoll.add(upper);

                // J3: Elbow
                const elbow = new THREE.Group();
                elbow.position.y = -0.4;
                upper.add(elbow);

                const lower = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), mat);
                lower.position.y = -0.4;
                elbow.add(lower);

                // J4, J5, J6: Wrist (Pitch, Roll, Yaw)
                const wrPitch = new THREE.Group();
                wrPitch.position.y = -0.4;
                lower.add(wrPitch);

                const wrRoll = new THREE.Group();
                wrPitch.add(wrRoll);

                const gripper = new THREE.Group();
                const gL = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.2, 0.1), jointMat);
                const gR = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.2, 0.1), jointMat);
                gL.position.x = -0.06; gR.position.x = 0.06;
                gripper.add(gL, gR);
                wrRoll.add(gripper);

                return { shPitch, shRoll, elbow, wrPitch, wrRoll, gL, gR };
            }

            async run() {
                const lines = document.getElementById('ilmInput').value.split('\n');
                for(let line of lines) {
                    if (line.trim().startsWith('//') || !line.trim()) continue;
                    const match = line.match(/(.+)\((.*)\)/);
                    if(match) {
                        const cmd = match[1].trim();
                        const val = match[2].trim();
                        await this.execute(cmd, val);
                    }
                }
            }

            async execute(cmd, val) {
                const rad = (parseFloat(val) * Math.PI) / 180;
                const isLeft = cmd.includes('_L_');
                const arm = isLeft ? this.arms.L : this.arms.R;

                if(cmd.includes('SH_PITCH')) arm.shPitch.rotation.x = rad;
                if(cmd.includes('SH_ROLL')) arm.shRoll.rotation.z = rad;
                if(cmd.includes('ELBOW')) arm.elbow.rotation.x = -rad;
                if(cmd.includes('WR_PITCH')) arm.wrPitch.rotation.x = rad;
                if(cmd.includes('WR_ROLL')) arm.wrRoll.rotation.y = rad;
                
                if(cmd.startsWith('GRIP')) {
                    const open = val.toUpperCase() === 'OPEN';
                    arm.gL.position.x = open ? -0.1 : -0.03;
                    arm.gR.position.x = open ? 0.1 : 0.03;
                }

                if(cmd === 'WALK') await this.walk(parseFloat(val));
                if(cmd === 'WAIT') await new Promise(r => setTimeout(r, parseFloat(val)*1000));
                if(cmd === 'RESET') this.resetAll();
                
                this.updateUI();
                await new Promise(r => setTimeout(r, 100));
            }

            updateUI() {
                document.getElementById('tel-ls').innerText = Math.round(this.arms.L.shPitch.rotation.x * 57) + '°';
                document.getElementById('tel-rs').innerText = Math.round(this.arms.R.shPitch.rotation.x * 57) + '°';
                document.getElementById('tel-eb').innerText = Math.round(this.arms.L.elbow.rotation.x * -57) + '°';
            }

            async walk(dist) {
                this.isWalking = true;
                let traveled = 0;
                while(traveled < dist) {
                    this.bot.position.z += 0.04;
                    traveled += 0.04;
                    await new Promise(r => setTimeout(r, 16));
                }
                this.isWalking = false;
                this.resetLegs();
            }

            resetAll() {
                this.bot.position.set(0,0,0);
                Object.values(this.arms).forEach(a => {
                    a.shPitch.rotation.set(0,0,0);
                    a.shRoll.rotation.set(0,0,0);
                    a.elbow.rotation.set(0,0,0);
                    a.wrPitch.rotation.set(0,0,0);
                    a.wrRoll.rotation.set(0,0,0);
                });
                this.updateUI();
            }

            resetLegs() {
                this.legs.L.hip.rotation.x = 0;
                this.legs.R.hip.rotation.x = 0;
            }

            resetView() { this.camera.position.set(6, 4, 8); this.controls.target.set(0,2,0); }

            animate() {
                requestAnimationFrame(() => this.animate());
                if(this.isWalking) {
                    this.walkTime += 0.12;
                    const swing = Math.sin(this.walkTime) * 0.5;
                    this.legs.L.hip.rotation.x = swing;
                    this.legs.R.hip.rotation.x = -swing;
                    this.legs.L.knee.rotation.x = swing > 0 ? 0.4 : 0;
                    this.legs.R.knee.rotation.x = swing < 0 ? 0.4 : 0;
                    this.bot.position.y = Math.abs(Math.cos(this.walkTime)) * 0.1;
                }
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }
        const sim = new HumanoidSim();
    </script>
</body>
</html>
